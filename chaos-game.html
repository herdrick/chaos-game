<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Interactive Chaos Game</title>
  <style>
    body {
      font-family: sans-serif;
    }
    #myCanvas {
      border: 1px solid #555;
      display: block;
      margin-top: 1em;
      cursor: default;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #555;
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
    }
  </style>
</head>
<body>
<div>Fool around with variations on the <a href="https://www.youtube.com/watch?v=k3V72Qvcn94">Chaos game</a>.</div>
<br/>
<br/>
<div id="spinner">Generating pixels...</div>
<div id="controls">
  <label for="vertices">Polygon Vertices:</label>
  <input type="number" id="vertices" value="3" min="2" max="100" />

  <label for="steps">Pixels:</label>
  <input type="number" id="steps" value="32000" step="50000" min="1" max="10000000"/>

  <label for="alpha">Opacity (0.0 - 1.0):</label>
  <input type="number" id="alpha" value="1" step="0.1" min="0" max="1" />

  <button id="generateBtn">Generate</button>
  <button id="resetBtn">Reset Vertices</button>
</div>
<div>(hint: More vertices or less opacity require more pixels. Less opacity exposes subtler structure.)</div>
<br/>
<canvas id="myCanvas" width="1000" height="1000"></canvas>

<script>
const cache = {};
let targets = [];  // Store vertex positions
let isDragging = false;
let draggedVertexIndex = -1;
const VERTEX_RADIUS = 8;
const HANDLE_RADIUS = 15; // Larger hit area for interaction
const CIRCLE_RADIUS = 475;


function getCacheKey(vertices, steps, alpha) {
  return `${vertices}_${steps}_${alpha}_${JSON.stringify(targets)}`;
}

function getCircleCoord(theta, x_center, y_center, radius) {
  const x = radius * Math.cos(theta) + x_center;
  const y = radius * Math.sin(theta) + y_center;
  return { x, y };
}

function initializeVertices(n_points) {
  targets = [];
  for (let i = 0; i < n_points; i++) {
    const shift = n_points == 2 ? Math.PI/6 : 0;  // Rotate by 30 degrees to make the 2 vertices version better
    const theta = (i / n_points) * 2 * Math.PI + shift
    targets.push(getCircleCoord(theta, 500, 500, CIRCLE_RADIUS));
  }
}

function generatePoints(steps, progressCallback) {
  let x = 100.0;
  let y = 100.0;
  const points = [];

  const chunkSize = 50000;
  let currentStep = 0;

  return new Promise((resolve) => {
    function generateChunk() {
      const endStep = Math.min(currentStep + chunkSize, steps);

      for (let i = currentStep; i < endStep; i++) {
        const nextTargetIdx = Math.floor(Math.random() * targets.length);
        const targetX = targets[nextTargetIdx].x;
        const targetY = targets[nextTargetIdx].y;

        x = (x + targetX) / 2.0;
        y = (y + targetY) / 2.0;
        points.push({ x, y });
      }

      currentStep = endStep;

      if (progressCallback) {
        progressCallback(currentStep / steps);
      }

      if (currentStep < steps) {
        setTimeout(generateChunk, 0);
      } else {
        resolve(points);
      }
    }

    generateChunk();
  });
}

function drawVerticesOnCanvas(ctx) {
  // Draw vertex handles
  targets.forEach((target, i) => {
    // Draw outer handle circle
    ctx.beginPath();
    ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
    ctx.arc(target.x, target.y, HANDLE_RADIUS, 0, 2 * Math.PI);
    ctx.fill();

    // Draw inner vertex circle
    ctx.beginPath();
    ctx.fillStyle = i === draggedVertexIndex ? '#A2D5F4' : '#4285F4';
    ctx.arc(target.x, target.y, VERTEX_RADIUS, 0, 2 * Math.PI);
    ctx.fill();

  });
}

function drawPointsOnCanvas(ctx, points, canvasWidth, canvasHeight, alphaValue) {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  // Draw points
  ctx.fillStyle = `rgba(0, 0, 0, ${alphaValue})`;  // black
  for (let i = 0; i < points.length; i++) {
    ctx.fillRect(points[i].x, points[i].y, 1, 1);
  }

  // Draw vertices on top
  drawVerticesOnCanvas(ctx);
}

function toggleSpinner(show) {
  const spinner = document.getElementById('spinner');
  spinner.style.display = show ? 'block' : 'none';
}

async function generateAndDraw() {
  const vertices = parseInt(document.getElementById('vertices').value, 10);
  const steps = parseInt(document.getElementById('steps').value, 10);
  const alphaValue = parseFloat(document.getElementById('alpha').value);

  const generateBtn = document.getElementById('generateBtn');
  generateBtn.disabled = true;

  toggleSpinner(true);

  try {
    // Initialize vertices if needed
    if (targets.length !== vertices) {
      initializeVertices(vertices);
    }

    const cacheKey = getCacheKey(vertices, steps, alphaValue);
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    if (cache[cacheKey]) {
      console.log(`Using cached image for key: ${cacheKey}`);
      ctx.putImageData(cache[cacheKey], 0, 0);
    } else {
      console.log(`Generating new image for key: ${cacheKey}`);

      await new Promise(resolve => setTimeout(resolve, 50));

      const points = await generatePoints(steps, (progress) => {
        document.getElementById('spinner').textContent =
          `Generating pixels... ${Math.round(progress * 100)}%`;
      });

      drawPointsOnCanvas(ctx, points, canvas.width, canvas.height, alphaValue);
      cache[cacheKey] = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }
  } catch (error) {
    console.error('Error:', error);
  } finally {
    toggleSpinner(false);
    generateBtn.disabled = false;
  }
}

// Mouse interaction handlers
function getVertexAtPosition(canvasX, canvasY) {
  for (let i = 0; i < targets.length; i++) {
    const dx = targets[i].x - canvasX;
    const dy = targets[i].y - canvasY;
    if (dx * dx + dy * dy < HANDLE_RADIUS * HANDLE_RADIUS) {
      return i;
    }
  }
  return -1;
}

function handleMouseMove(e) {
  const canvas = document.getElementById('myCanvas');
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (isDragging && draggedVertexIndex !== -1) {
    targets[draggedVertexIndex] = {x, y};

    // Redraw immediately with current points
    const ctx = canvas.getContext('2d');
    const alphaValue = parseFloat(document.getElementById('alpha').value);
    drawPointsOnCanvas(ctx, [], canvas.width, canvas.height, alphaValue);

    // Debounced regeneration
    clearTimeout(canvas.regenerateTimeout);
    canvas.regenerateTimeout = setTimeout(generateAndDraw, 100);
  } else {
    // Update cursor based on hover
    const hoveredIndex = getVertexAtPosition(x, y);
    canvas.style.cursor = hoveredIndex !== -1 ? 'move' : 'default';
  }
}

function handleMouseDown(e) {
  const canvas = document.getElementById('myCanvas');
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  draggedVertexIndex = getVertexAtPosition(x, y);
  if (draggedVertexIndex !== -1) {
    isDragging = true;
    canvas.classList.add('dragging');
  }
}

function handleMouseUp() {
  const canvas = document.getElementById('myCanvas');
  isDragging = false;
  draggedVertexIndex = -1;
  canvas.classList.remove('dragging');
}

// Setup event listeners
const canvas = document.getElementById('myCanvas');
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('mouseleave', handleMouseUp);

document.getElementById('generateBtn').addEventListener('click', generateAndDraw);
document.getElementById('resetBtn').addEventListener('click', () => {
  const vertices = parseInt(document.getElementById('vertices').value, 10);
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');

  initializeVertices(vertices);

  // Clear canvas and only draw vertices
  //ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawVerticesOnCanvas(ctx);
});

// Initial generation
generateAndDraw();
</script>
</body>
</html>
