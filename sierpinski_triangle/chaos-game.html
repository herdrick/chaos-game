<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Interactive Chaos Game</title>
  <style>
    body {
      font-family: sans-serif;
    }
    #controls {
      margin-bottom: 1em;
    }
    #myCanvas {
      border: 1px solid #555;
      display: block;
      margin-top: 1em;
      cursor: default;
    }
    #myCanvas.dragging {
      cursor: move;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #555;
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
    }
  </style>
</head>
<body>
<div id="spinner">Generating pixels...</div>
<div id="controls">
  <label for="vertices">Polygon Vertices:</label>
  <input type="number" id="vertices" value="3" min="2" max="100" />

  <label for="steps">Steps:</label>
  <input type="number" id="steps" value="16384" min="1" />

  <label for="alpha">Alpha (transparency, 0.0 - 1.0):</label>
  <input type="number" id="alpha" value="0.1" step="0.01" min="0" max="1" />

  <button id="generateBtn">Generate</button>
  <button id="resetBtn">Reset Vertices</button>
</div>

<canvas id="myCanvas" width="800" height="800"></canvas>

<script>
const cache = {};
let targets = [];  // Store vertex positions
let isDragging = false;
let draggedVertexIndex = -1;
const VERTEX_RADIUS = 8;
const HANDLE_RADIUS = 15; // Larger hit area for interaction

// Transform between canvas and math coordinates
const SCALE = 0.4;
const CIRCLE_RADIUS = 750;

function toCanvasCoords(x, y) {
  const canvas = document.getElementById('myCanvas');
  return {
    x: x * SCALE + canvas.width / 2,
    y: y * SCALE + canvas.height / 2
  };
}

function toMathCoords(canvasX, canvasY) {
  const canvas = document.getElementById('myCanvas');
  return {
    x: (canvasX - canvas.width / 2) / SCALE,
    y: (canvasY - canvas.height / 2) / SCALE
  };
}

function getCacheKey(vertices, steps, alpha) {
  return `${vertices}_${steps}_${alpha}_${JSON.stringify(targets)}`;
}

function getCircleCoord(theta, x_center, y_center, radius) {
  const x = radius * Math.cos(theta) + x_center;
  const y = radius * Math.sin(theta) + y_center;
  return { x, y };
}

function initializeVertices(n_points) {
  targets = [];
  for (let i = 0; i < n_points; i++) {
    const theta = (i / n_points) * 2 * Math.PI + 0.5;
    targets.push(getCircleCoord(theta, 0, 0, CIRCLE_RADIUS));
  }
}

function generatePolygonPoints2d(steps, progressCallback) {
  let x = 100.0;
  let y = 100.0;
  const points = [];

  const chunkSize = 1000;
  let currentStep = 0;

  return new Promise((resolve) => {
    function generateChunk() {
      const endStep = Math.min(currentStep + chunkSize, steps);

      for (let i = currentStep; i < endStep; i++) {
        const randIndex = Math.floor(Math.random() * targets.length);
        const tx = targets[randIndex].x;
        const ty = targets[randIndex].y;

        x = (x + tx) / 2.0;
        y = (y + ty) / 2.0;
        points.push({ x, y });
      }

      currentStep = endStep;

      if (progressCallback) {
        progressCallback(currentStep / steps);
      }

      if (currentStep < steps) {
        setTimeout(generateChunk, 0);
      } else {
        resolve(points);
      }
    }

    generateChunk();
  });
}

function drawPointsOnCanvas(ctx, points, canvasWidth, canvasHeight, alphaValue) {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  // Draw fractal points
  ctx.globalAlpha = alphaValue;
  ctx.fillStyle = "black";

  for (let i = 0; i < points.length; i++) {
    const {x, y} = toCanvasCoords(points[i].x, points[i].y);
    ctx.fillRect(x, y, 1, 1);
  }

  // Draw vertices with handles
  ctx.globalAlpha = 1.0;


  // Draw vertex handles
  targets.forEach((target, i) => {
    const {x, y} = toCanvasCoords(target.x, target.y);

    // Draw outer handle circle
    ctx.beginPath();
    ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
    ctx.arc(x, y, HANDLE_RADIUS, 0, 2 * Math.PI);
    ctx.fill();

    // Draw inner vertex circle
    ctx.beginPath();
    ctx.fillStyle = i === draggedVertexIndex ? '#ff4444' : '#4444ff';
    ctx.arc(x, y, VERTEX_RADIUS, 0, 2 * Math.PI);
    ctx.fill();

    // Add vertex number
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '12px sans-serif';
    ctx.fillText(i + 1, x, y);
  });
}

function toggleSpinner(show) {
  const spinner = document.getElementById('spinner');
  spinner.style.display = show ? 'block' : 'none';
}

async function generateAndDraw() {
  const vertices = parseInt(document.getElementById('vertices').value, 10);
  const steps = parseInt(document.getElementById('steps').value, 10);
  const alphaValue = parseFloat(document.getElementById('alpha').value);

  const generateBtn = document.getElementById('generateBtn');
  generateBtn.disabled = true;

  toggleSpinner(true);

  try {
    // Initialize vertices if needed
    if (targets.length !== vertices) {
      initializeVertices(vertices);
    }

    const cacheKey = getCacheKey(vertices, steps, alphaValue);
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    if (cache[cacheKey]) {
      console.log(`Using cached image for key: ${cacheKey}`);
      ctx.putImageData(cache[cacheKey], 0, 0);
    } else {
      console.log(`Generating new image for key: ${cacheKey}`);

      await new Promise(resolve => setTimeout(resolve, 50));

      const points = await generatePolygonPoints2d(steps, (progress) => {
        document.getElementById('spinner').textContent =
          `Generating pixels... ${Math.round(progress * 100)}%`;
      });

      drawPointsOnCanvas(ctx, points, canvas.width, canvas.height, alphaValue);
      cache[cacheKey] = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }
  } catch (error) {
    console.error('Error generating fractal:', error);
  } finally {
    toggleSpinner(false);
    generateBtn.disabled = false;
  }
}

// Mouse interaction handlers
function getVertexAtPosition(canvasX, canvasY) {
  for (let i = 0; i < targets.length; i++) {
    const {x, y} = toCanvasCoords(targets[i].x, targets[i].y);
    const dx = x - canvasX;
    const dy = y - canvasY;
    if (dx * dx + dy * dy < HANDLE_RADIUS * HANDLE_RADIUS) {
      return i;
    }
  }
  return -1;
}

function handleMouseMove(e) {
  const canvas = document.getElementById('myCanvas');
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (isDragging && draggedVertexIndex !== -1) {
    const mathCoords = toMathCoords(x, y);
    targets[draggedVertexIndex] = mathCoords;

    // Redraw immediately with current points
    const ctx = canvas.getContext('2d');
    const alphaValue = parseFloat(document.getElementById('alpha').value);
    drawPointsOnCanvas(ctx, [], canvas.width, canvas.height, alphaValue);

    // Debounced regeneration
    clearTimeout(canvas.regenerateTimeout);
    canvas.regenerateTimeout = setTimeout(generateAndDraw, 100);
  } else {
    // Update cursor based on hover
    const hoveredIndex = getVertexAtPosition(x, y);
    canvas.style.cursor = hoveredIndex !== -1 ? 'move' : 'default';
  }
}

function handleMouseDown(e) {
  const canvas = document.getElementById('myCanvas');
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  draggedVertexIndex = getVertexAtPosition(x, y);
  if (draggedVertexIndex !== -1) {
    isDragging = true;
    canvas.classList.add('dragging');
  }
}

function handleMouseUp() {
  const canvas = document.getElementById('myCanvas');
  isDragging = false;
  draggedVertexIndex = -1;
  canvas.classList.remove('dragging');
}

// Setup event listeners
const canvas = document.getElementById('myCanvas');
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('mouseleave', handleMouseUp);

document.getElementById('generateBtn').addEventListener('click', generateAndDraw);
document.getElementById('resetBtn').addEventListener('click', () => {
  const vertices = parseInt(document.getElementById('vertices').value, 10);
  initializeVertices(vertices);
  //generateAndDraw();
});

// Initial generation
generateAndDraw();
</script>
</body>
</html>
