<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chaos Game with Image Caching</title>
  <style>
    body {
      font-family: sans-serif;
    }
    #controls {
      margin-bottom: 1em;
    }
    #myCanvas {
      border: 1px solid #555;
      display: block;
      margin-top: 1em;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #555;
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
    }
  </style>
</head>
<body>
<div id="spinner">Generating pixels...</div>
<div id="controls">
  <label for="vertices">Polygon Vertices:</label>
  <input type="number" id="vertices" value="3" min="2" max="100" />

  <label for="steps">Steps:</label>
  <input type="number" id="steps" value="16384" min="1" />

  <label for="alpha">Alpha (transparency, 0.0 - 1.0):</label>
  <input type="number" id="alpha" value="0.1" step="0.01" min="0" max="1" />

  <button id="generateBtn">Generate</button>
</div>

<canvas id="myCanvas" width="800" height="800"></canvas>

<script>
const cache = {};

function getCacheKey(vertices, steps, alpha) {
  return `${vertices}_${steps}_${alpha}`;
}

function getCircleCoord(theta, x_center, y_center, radius) {
  const x = radius * Math.cos(theta) + x_center;
  const y = radius * Math.sin(theta) + x_center;
  return { x, y };
}

function getAllCircleCoords(x_center, y_center, radius, n_points) {
  const circleCoords = [];
  for (let i = 0; i < n_points; i++) {
    const theta = (i / n_points) * 2 * Math.PI + 0.5;
    circleCoords.push(getCircleCoord(theta, x_center, y_center, radius));
  }
  return circleCoords;
}

function generatePolygonPoints2d(polygonOrder, steps, progressCallback) {
  const targets = getAllCircleCoords(0, 0, 750, polygonOrder);
  let x = 100.0;
  let y = 100.0;
  const points = [];

  // Break the generation into chunks
  const chunkSize = 1000;
  let currentStep = 0;

  return new Promise((resolve) => {
    function generateChunk() {
      const endStep = Math.min(currentStep + chunkSize, steps);

      for (let i = currentStep; i < endStep; i++) {
        const randIndex = Math.floor(Math.random() * targets.length);
        const tx = targets[randIndex].x;
        const ty = targets[randIndex].y;

        x = (x + tx) / 2.0;
        y = (y + ty) / 2.0;
        points.push({ x, y });
      }

      currentStep = endStep;

      if (progressCallback) {
        progressCallback(currentStep / steps);
      }

      if (currentStep < steps) {
        setTimeout(generateChunk, 0);
      } else {
        resolve(points);
      }
    }

    generateChunk();
  });
}

function drawPointsOnCanvas(ctx, points, canvasWidth, canvasHeight, alphaValue) {
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  const scale = 0.4;
  const offsetX = canvasWidth / 2;
  const offsetY = canvasHeight / 2;

  ctx.globalAlpha = alphaValue;
  ctx.fillStyle = "black";

  for (let i = 0; i < points.length; i++) {
    const sx = points[i].x * scale + offsetX;
    const sy = points[i].y * scale + offsetY;
    ctx.fillRect(sx, sy, 1, 1);
  }
}

function toggleSpinner(show) {
  const spinner = document.getElementById('spinner');
  spinner.style.display = show ? 'block' : 'none';
}

async function generateAndDraw() {
  const vertices = parseInt(document.getElementById('vertices').value, 10);
  const steps = parseInt(document.getElementById('steps').value, 10);
  const alphaValue = parseFloat(document.getElementById('alpha').value);

  // Disable the generate button
  const generateBtn = document.getElementById('generateBtn');
  generateBtn.disabled = true;

  toggleSpinner(true);

  try {
    const cacheKey = getCacheKey(vertices, steps, alphaValue);
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    if (cache[cacheKey]) {
      console.log(`Using cached image for key: ${cacheKey}`);
      ctx.putImageData(cache[cacheKey], 0, 0);
    } else {
      console.log(`Generating new image for key: ${cacheKey}`);

      // Add a small delay to ensure the spinner is visible
      await new Promise(resolve => setTimeout(resolve, 50));

      const points = await generatePolygonPoints2d(vertices, steps, (progress) => {
        document.getElementById('spinner').textContent =
          `Generating pixels... ${Math.round(progress * 100)}%`;
      });

      drawPointsOnCanvas(ctx, points, canvas.width, canvas.height, alphaValue);
      cache[cacheKey] = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }
  } catch (error) {
    console.error('Error generating fractal:', error);
  } finally {
    toggleSpinner(false);
    generateBtn.disabled = false;
  }
}

document.getElementById('generateBtn').addEventListener('click', generateAndDraw);
generateAndDraw();
</script>
</body>
</html>
