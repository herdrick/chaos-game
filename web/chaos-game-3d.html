<!-- ported from the 2d web version by Claude 3.5 Sonnet -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Interactive Chaos Game</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #555;
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
    }
  </style>
</head>
<body>
<div id="controls">
  <label for="vertices">Vertices:</label>
  <input type="number" id="vertices" value="4" min="3" max="20" />

  <label for="points">Points:</label>
  <input type="number" id="points" value="10000" step="1000" min="1000" max="1000000"/>

  <label for="size">Point Size:</label>
  <input type="number" id="size" value="0.5" step="0.1" min="0.1" max="2.0" />

  <button id="generateBtn">Generate</button>
</div>
<div id="spinner">Generating points...</div>

<script type="module">
import * as THREE from './lib/three/0.172.0/three.module.js';

import { OrbitControls } from './lib/three/0.172.0/examples/jsm/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let vertices = [];
let points;
const SPHERE_RADIUS = 5;

function init() {
  // Scene setup
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);

  // Camera setup
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 15;

  // Renderer setup
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Controls setup
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Add lights
  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  scene.add(light);

  // Add coordinate axes helper
  const axesHelper = new THREE.AxesHelper(SPHERE_RADIUS + 1);
  scene.add(axesHelper);

  animate();
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

function createVertices(numVertices) {
  vertices = [];
  // Remove old vertex spheres
  scene.children = scene.children.filter(child => !(child instanceof THREE.Mesh && child.userData.isVertex));

  // Create vertices on a sphere using fibonacci sphere distribution
  const goldenRatio = (1 + Math.sqrt(5)) / 2;

  for(let i = 0; i < numVertices; i++) {
    const phi = Math.acos(1 - 2 * (i + 0.5) / numVertices);
    const theta = 2 * Math.PI * i / goldenRatio;

    const x = SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta);
    const y = SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta);
    const z = SPHERE_RADIUS * Math.cos(phi);

    vertices.push(new THREE.Vector3(x, y, z));

    // Add visible vertex as small sphere
    const geometry = new THREE.SphereGeometry(0.2);
    const material = new THREE.MeshPhongMaterial({ color: 0x4285F4 });
    const vertexMesh = new THREE.Mesh(geometry, material);
    vertexMesh.position.set(x, y, z);
    vertexMesh.userData.isVertex = true;
    scene.add(vertexMesh);
  }
}

async function generatePoints(numPoints, pointSize) {
  if (points) {
    scene.remove(points);
  }

  const positions = [];
  let currentPoint = new THREE.Vector3(1, 1, 1);

  // Generate points using the chaos game algorithm in 3D
  for (let i = 0; i < numPoints; i++) {
    const targetVertex = vertices[Math.floor(Math.random() * vertices.length)];
    currentPoint.lerp(targetVertex, 0.5);
    positions.push(currentPoint.x, currentPoint.y, currentPoint.z);

    if (i % 1000 === 0) {
      await new Promise(resolve => setTimeout(resolve, 0));
      document.getElementById('spinner').textContent =
        `Generating points... ${Math.round((i / numPoints) * 100)}%`;
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

  const material = new THREE.PointsMaterial({
    size: pointSize,
    color: 0x000000,
    sizeAttenuation: true,
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);
}

async function handleGenerate() {
  const numVertices = parseInt(document.getElementById('vertices').value);
  const numPoints = parseInt(document.getElementById('points').value);
  const pointSize = parseFloat(document.getElementById('size').value);

  document.getElementById('spinner').style.display = 'block';
  document.getElementById('generateBtn').disabled = true;

  createVertices(numVertices);
  await generatePoints(numPoints, pointSize);

  document.getElementById('spinner').style.display = 'none';
  document.getElementById('generateBtn').disabled = false;
}

// Event listeners
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('generateBtn').addEventListener('click', handleGenerate);

// Initialize scene and generate first set of points
init();
handleGenerate();
</script>
</body>
</html>
