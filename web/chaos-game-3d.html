<!-- ported from the 2d web version by Claude 3.5 Sonnet -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Interactive Chaos Game</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
    }
    #spinner {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #555;
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      z-index: 1000;
    }
  </style>
</head>
<body>
<div id="controls">
  <label for="vertices">Vertices:</label>
  <input type="number" id="vertices" value="4" min="3" max="20" />

  <label for="points">Points:</label>
  <input type="number" id="points" value="10000" step="1000" min="1000" max="1000000"/>

  <label for="size">Point Size:</label>
  <input type="number" id="size" value="0.5" step="0.1" min="0.1" max="2.0" />

  <button id="generateBtn">Generate</button>
</div>
<div id="spinner">Generating points...</div>

<script type="module">
import * as THREE from './lib/three/0.172.0/three.module.js';

import { OrbitControls } from './lib/three/0.172.0/examples/jsm/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let vertices = [];
let points;
const SPHERE_RADIUS = 5;

function normalize(point) {
    const norm = Math.sqrt(point[0] * point[0] + point[1] * point[1] + point[2] * point[2]);
    return new THREE.Vector3(point[0] / norm, point[1] / norm, point[2] / norm);

}

function tetrahedron() {
    const points = [
        [1, 1, 1],
        [1, -1, -1],
        [-1, 1, -1],
        [-1, -1, 1]
    ];
    return points.map(normalize);
}

function octahedron() {
    const points = [
        [1, 0, 0], [-1, 0, 0],
        [0, 1, 0], [0, -1, 0],
        [0, 0, 1], [0, 0, -1]
    ];
    return points.map(normalize);
}

function cube() {
    const points = [
        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]
    ];
    return points.map(normalize);
}

function icosahedron() {
    const phi = (1 + Math.sqrt(5)) / 2;  // Golden ratio
    const points = [
        [0, 1, phi], [0, 1, -phi], [0, -1, phi], [0, -1, -phi],
        [1, phi, 0], [1, -phi, 0], [-1, phi, 0], [-1, -phi, 0],
        [phi, 0, 1], [phi, 0, -1], [-phi, 0, 1], [-phi, 0, -1]
    ];
    return points.map(normalize);
}

function dodecahedron() {
    const phi = (1 + Math.sqrt(5)) / 2;  // Golden ratio
    const points = [
        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
        [0, 1/phi, phi], [0, 1/phi, -phi], [0, -1/phi, phi], [0, -1/phi, -phi],
        [1/phi, phi, 0], [1/phi, -phi, 0], [-1/phi, phi, 0], [-1/phi, -phi, 0],
        [phi, 0, 1/phi], [phi, 0, -1/phi], [-phi, 0, 1/phi], [-phi, 0, -1/phi]
    ];
    return points.map(normalize);
}


function getEquidistantPointsOnUnitSphereApproximation(n) {
    // Fibonacci lattice method
    const points = [];
    const offset = 2 / n;
    const increment = Math.PI * (3 - Math.sqrt(5)); // Golden angle in radians

    for (let i = 0; i < n; i++) {
        const y = ((i * offset) - 1) + (offset / 2);
        const r = Math.sqrt(1 - y * y);
        const phi = i * increment;

        const x = Math.cos(phi) * r;
        const z = Math.sin(phi) * r;

        points.push([x, y, z]);
    }

    return points.map(normalize);
}

function getEquidistantPointsOnSphere(radius, nPoints) {
    let points = [];

    // Check for platonic solids
    if (nPoints === 4) points = tetrahedron();
    else if (nPoints === 6) points = octahedron();
    else if (nPoints === 8) points = cube();
    else if (nPoints === 12) points = icosahedron();
    else if (nPoints === 20) points = dodecahedron();
    else {
        console.log('There is no exact equal distribution of points on a sphere so we will find an approximation');
        points = getEquidistantPointsOnUnitSphereApproximation(nPoints);
    }

    // Scale by radius
    return points.map(p => new THREE.Vector3(
        p.x * radius,
        p.y * radius,
        p.z * radius
    ));
}


function init() {
  // Scene setup
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);

  // Camera setup
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 15;

  // Renderer setup
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Controls setup
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Add lights
  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  scene.add(light);

  // Add coordinate axes helper
  const axesHelper = new THREE.AxesHelper(SPHERE_RADIUS + 1);
  scene.add(axesHelper);

  animate();
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

function createVertices(numVertices) {
  // Remove old vertex spheres
  scene.children = scene.children.filter(child => !(child instanceof THREE.Mesh && child.userData.isVertex));

  vertices = getEquidistantPointsOnSphere(SPHERE_RADIUS, numVertices);
  // for(let i = 0; i < numVertices; i++) {
  vertices.forEach(vertex => {
    // Add visible vertex as small sphere
    const geometry = new THREE.SphereGeometry(0.2);
    const material = new THREE.MeshPhongMaterial({ color: 0x4285F4 });
    const vertexMesh = new THREE.Mesh(geometry, material);
    vertexMesh.position.set(vertex.x, vertex.y, vertex.z);
    vertexMesh.userData.isVertex = true;
    scene.add(vertexMesh);
  })
}

async function generatePoints(numPoints, pointSize) {
  if (points) {
    scene.remove(points);
  }

  const positions = [];
  let currentPoint = new THREE.Vector3(1, 1, 1);

  // Generate points using the chaos game algorithm in 3D
  for (let i = 0; i < numPoints; i++) {
    const targetVertex = vertices[Math.floor(Math.random() * vertices.length)];
    currentPoint.lerp(targetVertex, 0.5);
    positions.push(currentPoint.x, currentPoint.y, currentPoint.z);

    if (i % 1000 === 0) {
      await new Promise(resolve => setTimeout(resolve, 0));
      document.getElementById('spinner').textContent =
        `Generating points... ${Math.round((i / numPoints) * 100)}%`;
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

  const material = new THREE.PointsMaterial({
    size: pointSize,
    color: 0x000000,
    sizeAttenuation: true,
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);
}

async function handleGenerate() {
  const numVertices = parseInt(document.getElementById('vertices').value);
  const numPoints = parseInt(document.getElementById('points').value);
  const pointSize = parseFloat(document.getElementById('size').value);

  document.getElementById('spinner').style.display = 'block';
  document.getElementById('generateBtn').disabled = true;

  createVertices(numVertices);
  await generatePoints(numPoints, pointSize);

  document.getElementById('spinner').style.display = 'none';
  document.getElementById('generateBtn').disabled = false;
}

// Event listeners
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById('generateBtn').addEventListener('click', handleGenerate);

// Initialize scene and generate first set of points
init();
handleGenerate();
</script>
</body>
</html>
